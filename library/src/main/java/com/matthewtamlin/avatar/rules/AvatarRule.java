package com.matthewtamlin.avatar.rules;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.testing.compile.JavaFileObjects;
import com.matthewtamlin.avatar.compilation.CompilationResult;
import com.matthewtamlin.avatar.compilation.CompilerUtil;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.File;
import java.lang.annotation.Annotation;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;

import static com.matthewtamlin.avatar.util.IterableNullChecker.checkNotContainsNull;
import static com.matthewtamlin.java_utilities.checkers.NullChecker.checkNotNull;

/**
 * A test rule for compiling Java source code before testing. Once applied, the rule provides access to: <ul> <li>The
 * {@link ProcessingEnvironment} used during compilation.</li> <li>The {@link CompilationResult}.</li> <li>The {@link
 * RoundEnvironment}s generated by compilation.</li> <li>The {@link Element}s generated by compilation.</li></ul>
 * <p>
 * There are three mechanisms for getting the elements generated by compilation: <ul> <li>Annotate elements with {@link
 * ElementId} and call {@link #getElementsWithId(String)} or {@link #getElementWithUniqueId(String)}.</li> <li>Annotate
 * elements with any annotation and call {@link #getElementsWithAnnotation(Class)}.</li> <li>Call {@link
 * #getRootElements()}.</li></ul>
 */
public class AvatarRule implements TestRule {
	/**
	 * The sources to compile.
	 */
	private final Iterable<JavaFileObject> sources;
	
	/**
	 * If true, compilation must succeed without error.
	 */
	private final boolean requireSuccessfulCompilation;
	
	/**
	 * The round environments generated by compilation, in the order that they were generated.
	 */
	private final List<RoundEnvironment> roundEnvironments = new ArrayList<>();
	
	/**
	 * The root elements generated by compilation.
	 */
	private final Set<Element> rootElements = new HashSet<>();
	
	/**
	 * All elements that were generated by compilation with at least one annotation. Each key is the fully qualified
	 * name
	 * of an annotation, and the corresponding value is the set of elements that possess that annotation.
	 */
	private final Map<String, Set<Element>> elementsByAnnotationName = new HashMap<>();
	
	/**
	 * All elements that were generated by compilation with an {@link ElementId} annotation. Each key is an element ID,
	 * and the corresponding value is the set of elements with that ID.
	 */
	private final Map<String, Set<Element>> elementsById = new HashMap<>();
	
	/**
	 * The processing environment supplied by the system during compilation.
	 */
	private ProcessingEnvironment processingEnvironment;
	
	/**
	 * Whether or not compilation has finished. The rule may still be running even when this variable is true.
	 */
	private boolean compilationFinished;
	
	private AvatarRule(final Builder builder) {
		if (builder.sources == null || !builder.sources.iterator().hasNext()) {
			sources = ImmutableList.of(JavaFileObjects.forSourceString("", ""));
		} else {
			sources = builder.sources;
		}
		
		requireSuccessfulCompilation = builder.requireSuccessfulCompilation;
	}
	
	public static AvatarRule withoutSources() {
		return builder().build();
	}
	
	@Override
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				final Processor processor = new Processor(base);
				
				final CompilationResult compilationResult = CompilerUtil.compileUsingProcessor(processor, sources);
				
				if (requireSuccessfulCompilation && !compilationResult.success()) {
					throw new RuntimeException("Compilation failed. Use Builder" +
							".withSuccessfulCompilationRequired(boolean) to ignore errors.");
				}
				
				if (processor.getThrowableFromBaseStatement() != null) {
					throw processor.getThrowableFromBaseStatement();
				}
			}
		};
	}
	
	/**
	 * Gets the {@link ProcessingEnvironment} supplied by the system during compilation.
	 *
	 * @return the processing environment, not null
	 *
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public ProcessingEnvironment getProcessingEnvironment() {
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing processing environment.");
		}
		
		return processingEnvironment;
	}
	
	/**
	 * Convenience method for getting the {@link Elements} supplied by the system during compilation. Equivalent
	 * to calling {@code getProcessingEnvironment().getElementUtils()}.
	 *
	 * @return the element utils, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Elements getElementUtils() {
		return getProcessingEnvironment().getElementUtils();
	}
	
	/**
	 * Convenience method for getting the {@link Types} supplied by the system during compilation. Equivalent
	 * to calling {@code getProcessingEnvironment().getTypeUtils()}.
	 *
	 * @return the type utils, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Types getTypeUtils() {
		return getProcessingEnvironment().getTypeUtils();
	}
	
	/**
	 * Convenience method for getting the {@link Filer} supplied by the system during compilation. Equivalent
	 * to calling {@code getProcessingEnvironment().getFiler()}.
	 *
	 * @return the filer, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Filer getFiler() {
		return getProcessingEnvironment().getFiler();
	}
	
	/**
	 * Convenience method for getting the {@link Locale} supplied by the system during compilation. Equivalent
	 * to calling {@code getProcessingEnvironment().getLocale()}.
	 *
	 * @return the locale, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Locale getLocale() {
		return getProcessingEnvironment().getLocale();
	}
	
	/**
	 * Convenience method for getting the {@link Messager} supplied by the system during compilation. Equivalent
	 * to calling {@code getProcessingEnvironment().getMessager()}.
	 *
	 * @return the element utils, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Messager getMessager() {
		return getProcessingEnvironment().getMessager();
	}
	
	/**
	 * Gets the round environments generated by compilation.
	 *
	 * @return the round environments, may be empty, not null
	 *
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public List<RoundEnvironment> getRoundEnvironments() {
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing round environments.");
		}
		
		return roundEnvironments;
	}
	
	/**
	 * Gets all elements generated by compilation that match with the supplied ID. The ID of an element is defined by
	 * applying the {@link ElementId} annotation.
	 *
	 * @param id
	 * 		the ID to match with, not null
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getElementsWithId(final String id) {
		checkNotNull(id, "Argument \'id\' cannot be null.");
		
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (elementsById.containsKey(id)) {
			return elementsById.get(id);
		} else {
			return new HashSet<>();
		}
	}
	
	/**
	 * Gets the element generated by compilation that matches with the supplied ID. The ID of an element is defined by
	 * applying the {@link ElementId} annotation. An exception will be thrown if no matches are found or multiple
	 * matches
	 * are found.
	 *
	 * @param id
	 * 		the ID to match with, not null
	 *
	 * @return the element, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 * @throws UniqueElementNotFoundException
	 * 		if no matches are found or multiple matches are found
	 */
	@SuppressWarnings("unchecked")
	public <T extends Element> T getElementWithUniqueId(final String id) {
		checkNotNull(id, "Argument \'id\' cannot be null.");
		
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (getElementsWithId(id).isEmpty()) {
			throw new UniqueElementNotFoundException("No elements found for ID \'" + id + "\'.");
		}
		
		if (getElementsWithId(id).size() > 1) {
			throw new UniqueElementNotFoundException("Multiple elements found for ID \'" + id + "\'.");
		}
		
		return (T) getElementsWithId(id).iterator().next();
	}
	
	/**
	 * Gets all elements generated by compilation that are annotated with the supplied annotation.
	 *
	 * @param annotationClass
	 * 		the class of the annotation, not null
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getElementsWithAnnotation(Class<? extends Annotation> annotationClass) {
		checkNotNull(annotationClass, "Argument \'annotationClass\' cannot be null.");
		
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (elementsByAnnotationName.containsKey(annotationClass.getCanonicalName())) {
			return elementsByAnnotationName.get(annotationClass.getCanonicalName());
		} else {
			return new HashSet<>();
		}
	}
	
	/**
	 * Gets all root elements generated by compilation. A root element is any element at the top level of a source file.
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getRootElements() {
		if (!compilationFinished) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		return rootElements;
	}
	
	/**
	 * @return a new {@link Builder}, not null
	 */
	public static Builder builder() {
		return new Builder();
	}
	
	/**
	 * A processor which collects elements and other important objects during compilation, and assigns them to the
	 * member
	 * variables of the AvatarRule.
	 */
	private class Processor extends AbstractProcessor {
		private final Statement baseStatement;
		
		private Throwable baseThrowable;

		@Override
		public SourceVersion getSupportedSourceVersion()
		{
			return SourceVersion.latestSupported();
		}

		public Processor(final Statement baseStatement) {
			this.baseStatement = checkNotNull(baseStatement, "Argument \'baseStatement\' cannot be null.");
		}
		
		public Throwable getThrowableFromBaseStatement() {
			return baseThrowable;
		}
		
		@Override
		public synchronized void init(final ProcessingEnvironment processingEnvironment) {
			super.init(processingEnvironment);
			AvatarRule.this.processingEnvironment = processingEnvironment;
		}
		
		@Override
		public Set<String> getSupportedAnnotationTypes() {
			return ImmutableSet.of("*");
		}
		
		@Override
		public boolean process(
				final Set<? extends TypeElement> annotations,
				final RoundEnvironment roundEnvironment) {
			
			roundEnvironments.add(roundEnvironment);
			rootElements.addAll(roundEnvironment.getRootElements());
			
			collectElementsByAnnotation(annotations, roundEnvironment);
			collectElementsById(roundEnvironment);
			
			if (roundEnvironment.processingOver()) {
				compilationFinished = true;
				callBaseStatement();
			}
			
			return false;
		}
		
		/**
		 * Maps the elements in the supplied round environment to the supplied annotations. The mappings are added to
		 * the
		 * {@link AvatarRule#elementsByAnnotationName} map.
		 *
		 * @param annotations
		 * 		the annotations to map, not null
		 * @param roundEnvironment
		 * 		contains the elements to map, not null
		 */
		private void collectElementsByAnnotation(
				final Set<? extends TypeElement> annotations,
				final RoundEnvironment roundEnvironment) {
			
			for (final TypeElement annotation : annotations) {
				final String annotationName = annotation.getQualifiedName().toString();
				
				if (!elementsByAnnotationName.containsKey(annotationName)) {
					elementsByAnnotationName.put(annotationName, new HashSet<Element>());
				}
				
				elementsByAnnotationName
						.get(annotationName)
						.addAll(roundEnvironment.getElementsAnnotatedWith(annotation));
			}
		}
		
		/**
		 * Maps the elements in the supplied round environment to their IDs. The mappings are added to the {@link
		 * AvatarRule#elementsById} map. Elements with no ID are ignored.
		 *
		 * @param roundEnvironment
		 * 		contains the elements to map, not null
		 */
		private void collectElementsById(final RoundEnvironment roundEnvironment) {
			for (final Element e : roundEnvironment.getElementsAnnotatedWith(ElementId.class)) {
				final ElementId elementId = e.getAnnotation(ElementId.class);
				final String id = elementId.value();
				
				if (!elementsById.containsKey(id)) {
					elementsById.put(id, new HashSet<Element>());
				}
				
				elementsById.get(id).add(e);
			}
		}
		
		private void callBaseStatement() {
			try {
				baseStatement.evaluate();
			} catch (final Throwable t) {
				baseThrowable = t;
			}
		}
	}
	
	/**
	 * Builds {@link AvatarRule} instances.
	 */
	public static class Builder {
		/**
		 * The sources to compile. Must be non-null before building AvatarRule.
		 */
		private final Set<JavaFileObject> sources = new HashSet<>();
		
		/**
		 * Whether or not compilation must complete without error.
		 */
		private boolean requireSuccessfulCompilation = true;
		
		/**
		 * Constructs a new {@link AvatarRule} based on the values provided to this builder. The operation will fail if
		 * no sources have been set.
		 *
		 * @return the new AvatarRule, not null
		 */
		public AvatarRule build() {
			return new AvatarRule(this);
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the sources to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 */
		public Builder withSourceFileObjects(final Iterable<JavaFileObject> sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");
			checkNotContainsNull(sources, "Argument \'sources\' cannot contain null.");
			
			this.sources.addAll(ImmutableList.copyOf(sources));
			
			return this;
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the sources to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 */
		public Builder withSourceFileObjects(final JavaFileObject... sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");
			
			return withSourceFileObjects(Arrays.asList(sources));
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the source files to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the files are non-existent
		 */
		public Builder withSourceFiles(final Iterable<File> sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");
			
			final List<JavaFileObject> javaFileObjects = new ArrayList<>();
			
			for (final File source : sources) {
				checkNotNull(source, "Argument \'sources\' cannot contain null.");
				
				if (!source.exists()) {
					throw new IllegalArgumentException("File \'" + source + "\' does not exist.");
				}
				
				try {
					javaFileObjects.add(JavaFileObjects.forResource(source.toURI().toURL()));
				} catch (final MalformedURLException e) {
					throw new RuntimeException("Could not get URL for file \'" + source + "\'.", e);
				}
			}
			
			return withSourceFileObjects(javaFileObjects);
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the source files to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the files are non-existent
		 */
		public Builder withSourceFiles(final File... sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");
			
			return withSourceFiles(Arrays.asList(sources));
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the source resources to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the files are non-existent
		 */
		public Builder withSourceResources(final Iterable<URL> sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");

			final List<JavaFileObject> javaFileObjects = new ArrayList<>();

			for (final URL source : sources) {
				checkNotNull(source, "Argument \'sources\' cannot contain null.");

				javaFileObjects.add(JavaFileObjects.forResource(source));
			}

			return withSourceFileObjects(javaFileObjects);
		}

		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sources
		 * 		the source resources to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sources} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sources} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the files are non-existent
		 */
		public Builder withSourceResources(final URL... sources) {
			checkNotNull(sources, "Argument \'sources\' cannot be null.");

			return withSourceResources(Arrays.asList(sources));
		}

		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sourcePaths
		 * 		the paths of the source files to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sourcePaths} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sourcePaths} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the paths point to non-existent files
		 */
		public Builder withSourcesAt(final Iterable<String> sourcePaths) {
			checkNotNull(sourcePaths, "Argument \'sourcePaths\' cannot be null.");
			
			final List<File> files = new ArrayList<>();
			
			for (final String sourcePath : sourcePaths) {
				checkNotNull(sourcePath, "Argument \'sourcePaths\' cannot contain null.");
				
				final File sourceFile = new File(sourcePath);
				
				if (!sourceFile.exists()) {
					throw new IllegalArgumentException("File \'" + sourceFile + "\' does not exist.");
				}
				
				files.add(sourceFile);
			}
			
			return withSourceFiles(files);
		}
		
		/**
		 * Sets the sources to compile, adding to any that have been set previously.
		 *
		 * @param sourcePaths
		 * 		the paths of the source files to compile, not null, not containing null
		 *
		 * @return this builder
		 *
		 * @throws IllegalArgumentException
		 * 		if {@code sourcePaths} is null
		 * @throws IllegalArgumentException
		 * 		if {@code sourcePaths} contains null
		 * @throws IllegalArgumentException
		 * 		if any of the paths point to non-existent files
		 */
		public Builder withSourcesAt(final String... sourcePaths) {
			checkNotNull(sourcePaths, "Argument \'sourcePaths\' cannot be null.");
			
			return withSourcesAt(Arrays.asList(sourcePaths));
		}
		
		/**
		 * Sets whether or not compilation must succeed without error, replacing any value which has been set
		 * previously.
		 *
		 * @param required
		 * 		true if compilation must succeed without error, false otherwise
		 *
		 * @return this builder
		 */
		public Builder withSuccessfulCompilationRequired(final boolean required) {
			requireSuccessfulCompilation = required;
			
			return this;
		}
	}
}